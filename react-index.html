<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Audio Recorder and OpenAI Integration</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const App = () => {
            const [recording, setRecording] = useState(false);
            const [mediaRecorder, setMediaRecorder] = useState(null);
            const [audioChunks, setAudioChunks] = useState([]);
            const [transcription, setTranscription] = useState('');
            const [audioUrl, setAudioUrl] = useState(null);
            const [threadResponse, setThreadResponse] = useState(null);
            const [threadId, setThreadId] = useState(null);
            const [threadRunResponse, setThreadRunResponse] = useState(null);

            const apiKey = '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'; // Replace with your actual API key

            useEffect(() => {
                const handleKeyDown = (event) => {
                    if (event.key === 't' && !recording) {
                        startRecording();
                    }
                };

                const handleKeyUp = (event) => {
                    if (event.key === 't' && recording) {
                        stopRecording();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [recording]);

            const startRecording = async () => {
                setRecording(true);
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const recorder = new MediaRecorder(stream);
                setMediaRecorder(recorder);

                recorder.start();
                recorder.ondataavailable = (event) => {
                    setAudioChunks((prevChunks) => [...prevChunks, event.data]);
                };

                recorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    setAudioChunks([]);
                    console.log('Audio Blob:', audioBlob);

                    const formData = new FormData();
                    formData.append('file', audioBlob, 'audio.wav');
                    formData.append('model', 'whisper-1');

                    try {
                        const response = await axios.post('https://api.openai.com/v1/audio/transcriptions', formData, {
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'multipart/form-data'
                            }
                        });
                        console.log('Transcription response:', response.data);
                        setTranscription(response.data.text);
                        handleAndConvertToSpeech();
                    } catch (error) {
                        console.error('Error converting audio:', error.response.data);
                    }
                };
            };

            const stopRecording = () => {
                if (mediaRecorder) {
                    setRecording(false);
                    mediaRecorder.stop();
                } else {
                    console.error('MediaRecorder is not initialized');
                }
            };

            const textToSpeech = async (text) => {
                const url = 'https://api.openai.com/v1/audio/speech';
                const data = {
                    model: "tts-1",
                    input: text,
                    voice: "alloy"
                };

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });

                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    const blob = await response.blob();
                    return URL.createObjectURL(blob);
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                    throw error;
                }
            };

            const createThread = async () => {
                const url = 'http://localhost:3000/api/v1/eddie/threads/create-thread';

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create thread');
                    }

                    const data = await response.json();
                    setThreadResponse(JSON.stringify(data, null, 2));
                    setThreadId(data.id);
                } catch (error) {
                    console.error('Error creating thread:', error);
                    alert('Failed to create thread');
                }
            };

            const handleThreadRun = async () => {
                const url = 'http://localhost:3000/api/v1/eddie/threads/handle-thread-run';
                const data = {
                    message: transcription,
                    threadId: threadId
                };

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });

                    if (!response.ok) {
                        throw new Error('Failed to handle thread run');
                    }

                    const responseData = await response.json();
                    setThreadRunResponse(JSON.stringify(responseData, null, 2));
                    return responseData[0].text.value;
                } catch (error) {
                    console.error('Error handling thread run:', error);
                    alert('Failed to handle thread run');
                    throw error;
                }
            };

            const handleAndConvertToSpeech = async () => {
                try {
                    const text = await handleThreadRun();
                    const url = await textToSpeech(text);
                    setAudioUrl(url);
                } catch (error) {
                    console.error('Error in handleAndConvertToSpeech:', error);
                    alert('Failed to handle thread run and convert to speech');
                }
            };

            return (
                <div>
                    <h1>Audio Recorder and Speech-to-Text</h1>

                    {transcription && (
                        <div>
                            <h2>Transcription:</h2>
                            <p>{transcription}</p>
                        </div>
                    )}

                    {audioUrl && <audio src={audioUrl} controls autoPlay />}

                    <h2>Create Thread</h2>
                    <button onClick={createThread}>Create Thread</button>

                    {threadResponse && (
                        <div>
                            <h3>Thread Response:</h3>
                            <pre>{threadResponse}</pre>
                        </div>
                    )}

                    {threadId && (
                        <div>
                            <h3>Thread ID:</h3>
                            <p>{threadId}</p>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>

</html>